= The role of Quarkus in the modern Java ecosystem

From its inception in 2019, Quarkus gradually grows both in terms of its
user adoption and innovation. The number of its different research and
development areas is just enormous. It's one of the most active Java
projects you can find right now.

Last year, Quarkus celebrated its 5th birthday and one additional enormous
milestone -- 1000 contributors! Actually, there is already 59 more
contributors by now. And these are contributors of the main repository only,
not taking into account additional 170 repositories under the Quarkiverse
organization (which we tackle later in this article).

Quarkus pushes boundaries everywhere you can imagine. So, what does this say
about Quarkus's contribution to the Java ecosystem?

image::./images/1kcontributors.jpg[]

== Quarkus to the moon and beyond

Who could have imagined 6 years ago when a few very clever minds at Red Hat
came together and decided to design a new Java framework that it could
revolutionize the ways of Java development, that it would take off so fast.
Quarkus brought a new way of thinking to the engineering workflows -- a
framework that not only cares about the performance, but also puts excessive
emphasis on the developer experience.

In my experience, there is no issue proving that Quarkus has something to
offer to any kind of audience. High throughput, lower cloud costs, and
sustainability are easy to justify, especially when we have so many real
users and their applications that validate what Quarkus offers
(https://quarkus.io/userstories/).

However, I'm also an engineer. I love to code and I understand the pains of
the everyday development tasks. Which is why I was just blown away the first
time I opened Quarkus's Dev mode. Before that, I was used to either
application server workflow or rebuild of fat JAR after each change. The dev
mode was so amazing that all applications from there (even the tooling for
the application server) was powered by Quarkus from then on.

But there was one more thing that astonished me: how fast everything moved.
The level of activity in the Quarkus's GitHub repository was unknown to me
before. Pull requests were reviewed and merged so quickly that your PR would
be out of sync in hours (even minutes from time to time). Each issue was
automatically tagged for the right people to look. More importantly, the
rate of releases was just amazing. New release every two weeks and new
feature release every month. Quarkus is keeping this pace to this day
demonstrating the commitment to both the innovation and the community.

For the purposes of this article, we can split the main Quarkus features
that have an influence on its position in the Java ecosystem into three
categories:

- Performance characteristics and optimizations
- Dev mode and everything it encloses
- Community engagement and support

Feel free to jump to relevant parts if you are already familiar with
Quarkus's basics. But we need to start from the beginning to provide the
full picture of where Quarkus stands today.

== What is Quarkus?

If this is the first time you read about Quarkus, I want to start with a
brief overview of this framework is and what it aims to achieve. Java has
come a long way since it was created 30 years ago. Originally designed for
long-running applications that didn't worry too much about fast startup
times or low memory utilization. But that changed when we started moving our
workloads to clouds. These exact metrics became a prominent influence of our
production costs.

Most of the Java ecosystem wasn't ready for this change which was one of the
main drivers to create Quarkus. Quarkus provides a very modern approach to
application development while it is still built on the shoulders of giants --
popular and production years-tested technologies like Hibernate, Netty, or
Vert.x. This is why it's popularity skyrocketed since it was announced. And
it is still continuously growing.

Quarkus is an JVM framework for enterprise application development. It
provides a platform for building microservices, serverless, or traditional
monolithic applications. Additionally, you can also use Quarkus to build
command line (CLI) applications, edge, GitHub bots, GitHub actions, or
Kubernetes operators. And this is surely not exhaustive list.

=== Technology packed runtime

Quarkus's website defines Quarkus as "a Kubernetes Native Java stack
tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed
Java libraries and standards" (https://quarkus.io/, 2025). If we break it down:

_Kubernetes native_ means Quarkus makes sure that user experience in
Kubernetes is straightforward. It provides many different pieces of
functionalities that help with the Kubernetes deployments and management. In
some cases, you don't even have to write any YAML because Quarkus can
generate all descriptors for you.

By _tailored for OpenJDK HotSpot and GraalVM_, the definition means that
Quarkus aims to provide a suitable platform for both the traditional JVM
deployments (runnable JAR) and GraalVM (https://www.graalvm.org/) native
binaries. The native compilation with GraalVM takes the performance
mechanisms that Quarkus provides to another level. Natively built binaries
start in mere milliseconds and rely on a very low memory. Quarkus guarantees
that as long as you use the integrations provided by quarkus (called
extensions) you can free choose between the two. Compilation to native
binary with GraalVM is triggered by a simple flag switch. Quarkus integrates
all relevant configuration for the GraalVM so your application compiles
successfully.

_Crafted from the best of breed Java libraries and standards_ only says that
the technology stack behind Quarkus is not fully created from scratch. Many
of the included technologies have been around for some time (e.g., Vert.x,
Jackson, Hibernate). What Quarkus provides is a unique way of their
integrations that we look into next. But in the end, you use the same
Hibernate as in any other framework so the learning curves are quite short.

=== Build time/runtime split

Quarkus is a very performant framework because it splits all application
processing into two phases - build time and runtime. Every framework needs
to execute various tasks when your application start: loading and parsing of
the configuration, classpath scanning (annotations), analyzing dependencies,
creating application model. Traditional frameworks need to execute all these
operations when the application starts. Every time it starts. So with every
restart all of this processing needs to be repeated, even if the application
didn't change.

Quarkus moves as much of the framework processing to the build time -- to
when you compile and package your application. In this way, the results of
this processing are recorded and reused when the application starts. In
other words, they are computed during build time only once and reused in
runtime.

image:./images/build-time-principle-light.png[]

=== Extensions -- integrating with Quarkus

All the processing described above is further exposed for integrations that
are called extensions. Each extension integrates some library or
functionality so the extension developer can choose which parts of the
library processing can be executed during build time or what needs to be
done at runtime. For instance, imagine the path on which your OpenAPI
document is exposed. It isn't change that often so it's sufficient to only
record it once during build time. On the other hand, something like the port
on which our application runs would be unreasonable to fix at build time
since our application might run on different ports in different environments
so it is overridable at runtime.

Additionally, extensions can also provide any configuration for the seamless
GraalVM native builds. The extensions developers know the library that is
being integrated which means that they understand what kind of code the user
of their library needs to write. Providing any of the usually required
configuration for GraalVM build (e.g., reflectively accessed classes) is
thus done in the extension itself, so the users don't need to provide it
manually.

There are currently more than 750 extensions available at
https://quarkus.io/extensions/. Many library developers see the value that
Quarkus can bring to their users and want to provide an extension for them.
Because the number of extensions grew so quick that the Quarkus's main
repository (https://github.com/quarkusio/quarkus) started to get too big to
work with, we created the Quarkiverse (Quarkus + Universe). Quarkiverse is a
GitHub organization that encapsulates community Quarkus extensions that we
couldn't fit into the main repository. Individual repositories are
maintained by the community contributors but are fully integrated into the
Quarkus ecosystem. The repository maintainers can release their extensions
as they need, and Quarkus users can pick them for their application in the
exactly same way as with the core extension. This also means that if you
want to have your own Quarkus extension, all you need to do is to ping the
Quarkus team (GitHub or Zulip) and we can create a new repository for your
extension.

That's not all the extensions can do. One of the best features that Quarkus
provides are encapsulated in its development experience called the Dev mode.
Each extension can provide its own "magic" that makes the work with the
integrated library easier or just plainly more fun. Let's look into what we
can do in the Quarkus's Dev mode next.

== Developer-focused framework

In my opinion, whether any tech is liked or not is always first and foremost
about the technology. Ask yourself what is more important to you when you
are choosing your framework? Is it performance? Or the tooling support?
Quarkus's bet is that it is the overall development experience. And if you
think about it, so many frameworks and even some programming languages have
been created solely to improve the development experience.

=== Dev mode

While performance characteristics are surely important, they are mostly
relevant in production environments where we need to restrict utilized
resources. However, developers want a technology that helps them with the
application development. Technology that understands their needs and
provides simple way to solve their problems. And Quarkus invests heavily
into the developer experience (which pays back).

The single most important productivity tool in Quarkus is its Dev mode. Dev
mode is a continuous run of your Quarkus application in which Quarkus
embraced the concept of REPL (read-eval-print loop). By simply changing our
source code, Quarkus automatically recompiles and reruns our application,
showing the result of our work in mere milliseconds. But it doesn't stop
there.

Quarkus's Dev mode encompasses many other functionalities that we utilize in
our everyday tasks. These features include continuous testing, Dev UI, or
Dev Services make development such an enthusiastic experience, that it's not
surprising people like to use Quarkus.

=== Dev Services

Dev Services represent an abstraction of remote dependent services whether
it is a database (Postgres, MongoDB), messaging provider (Kafka, RabbitMQ),
or security (Keycloak). The Dev service is automatically started by the
Quarkus's Dev and test modes. So, you don't have to mix the provider
instances for development and test which is extremely useful in the
continuous testing we cover next. It essentially boils down to starting a
particular OCI (Docker or Podman) container for the particular provider
(utilizing Testcontainers), but it doesn't have to. Some Dev services (e.g.,
Derby or H2) start in-process.

You can disable most of the Dev services with configuration. Either with the
explicit disabling property or with an implicit definition of the
uniquely-defining instance of the provider. For instance, if you define the
connection URL to a database (`quarkus.datasource.jdbc.url`), Quarkus will
use your configured database and won't start a new container.

=== The power of Quarkus's Dev mode

To give you an idea of typical development workflow, I want to describe the
car rental application we develop in our latest Quarkus book called "Quarkus
in Action" which was released in January 2025 (there is a link to a free
e-book at the end of the article). The car rental application consists of
five Quarkus services that communicate together via various protocols and
messaging technologies including Apache Kafka, RabbitMQ, GraphQL, gRPC, and
REST:

image::./images/car-rental.png[]

In the architecture diagram, the Quarkus services represent user developed
services and are marked with the Quarkus logo. The Inventory CLI is an
example command line application that manages the cars fleet. You can find
the code at https://github.com/xstefank/quarkus-in-action. If we start the
remaining business services in Dev mode (they all run on different ports),
all remaining services start automatically as Dev Services (disclaimer, in
the book we use older Quarkus version that doesn't have the LGTM Dev service
- https://quarkus.io/guides/observability-devservices-lgtm). Together 10
containers that start automatically, just because we run all Quarkus
applications in Dev modes. We as users don't need to supply any
configuration for these services manually, but of course it's possible to
override the default if there is a need.

== Community engagement